<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gradyan Metin Oluşturucu</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }
    
        body {
            background-color: #f5f5f5;
            padding: 20px;
        }
    
        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: white;
            padding: 40px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
        }
    
        h1 {
            text-align: left;
            margin-bottom: 30px;
            color: #333;
        }
    
        .control-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
    
        .panel-section {
            display: grid;
            gap: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            margin-bottom: 15px;
        }
    
        label {
            margin-bottom: 8px;
            font-weight: 600;
            color: #34495e;
            font-size: 0.9rem;
            text-align: left;
            padding-left: 4px;
        }
    
        input, select {
            width: 100%;
            padding: 10px;
            border: 1px solid #e0e4e8;
            border-radius: 16px;
            font-size: 16px;
            transition: all 0.3s ease;
            appearance: none;
            background-color: #f9fafb;
        }
    
        input[type="color"] {
            height: 40px;
            padding: 0;
            min-height: 40px;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 16px;
        }

        .text-input {
            width: 100%;
            margin-bottom: 20px;
            margin-top: 20px;   
        }

        input:focus, select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }
    
        select {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath d='M10.3 3.3L6 7.6 1.7 3.3c-.4-.4-1-.4-1.4 0s-.4 1 0 1.4l5 5c.4.4 1 .4 1.4 0l5-5c.4-.4.4-1 0-1.4s-1-.4-1.4 0z' fill='%23718096'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 12px;
        }

        .preview {
            background-color: #f9f9f9;
            padding: 30px;
            border-radius: 16px;
            min-height: 200px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            border: 1px solid #eee;
            position: relative;
            overflow: hidden;
        }
    
        .preview-text {
            word-wrap: break-word;
            max-width: 100%;
            position: relative;
            z-index: 1;
        }
    
        button {
            background-color: #007BFF;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 100px;
            cursor: pointer;
            font-weight: bold;
            margin-right: 10px;
            transition: background-color 0.3s;
        }
    
        .button-group {
            text-align: center;
        }
    
        button:hover {
            background-color: #0056b3;
        }

        .code-output {
            background-color: #f0f0f0;
            padding: 20px;
            border-radius: 16px;
            margin-top: 20px;
            border: 1px solid #ddd;
            white-space: pre-wrap;
            font-family: monospace;
            display: none;
        }

        textarea {
            width: 100%;
            height: 100px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 16px;
            resize: vertical;
            font-family: inherit;
            font-size: 16px;
            min-height: 80px;
        }

        /* Gradient Direction Control */
        .gradient-control {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        .gradient-line {
            position: absolute;
            width: 2px;
            background-color: #333;
            z-index: 2;
            transform-origin: center;
            transform-origin: top center;
        }

        .gradient-circle {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            position: absolute;
            cursor: move;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            transition: transform 0.2s ease;
            pointer-events: auto;
            z-index: 3;
            border: 2px solid #fff;
        }

        .start-circle {
            top: 25%;
            left: 35%;
        }

        .end-circle {
            top: 75%;
            left: 65%;
        }

        .gradient-circle:hover {
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Gradyan Metin Oluşturucu</h1>
        
        <div class="text-input">
            <label for="userText">Metninizi girin:</label>
            <textarea id="userText">Gradyan örnek metin!</textarea>
        </div>
        
        <div class="control-panel">
            <div class="panel-section">
                <div class="control-group">
                    <label for="firstColor">Başlangıç Rengi:</label>
                    <input type="color" id="firstColor" value="#ff0000">
                </div>
                
                <div class="control-group">
                    <label for="secondColor">Bitiş Rengi:</label>
                    <input type="color" id="secondColor" value="#0000ff">
                </div>
                
                <div class="control-group">
                    <label for="gradientDirection">Gradyan Yönü:</label>
                    <select id="gradientDirection">
                        <option value="to right">Soldan Sağa</option>
                        <option value="to left">Sağdan Sola</option>
                        <option value="to bottom">Yukarıdan Aşağıya</option>
                        <option value="to top">Aşağıdan Yukarıya</option>
                        <option value="to bottom right">Köşegen (Sol Üst - Sağ Alt)</option>
                        <option value="to bottom left">Köşegen (Sağ Üst - Sol Alt)</option>
                        <option value="custom">Özel Gradyan</option>
                    </select>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="control-group">
                    <label for="fontSize">Yazı Boyutu (px):</label>
                    <input type="number" id="fontSize" value="30" min="12" max="100">
                </div>
                
                <div class="control-group">
                    <label for="lineHeight">Satır Aralığı:</label>
                    <input type="number" id="lineHeight" value="1.5" min="0.8" max="3" step="0.1">
                </div>
                
                <div class="control-group">
                    <label for="textAlign">Metin Hizalama:</label>
                    <select id="textAlign">
                        <option value="left">Sola Hizalı</option>
                        <option value="center">Ortalanmış</option>
                        <option value="right">Sağa Hizalı</option>
                    </select>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="control-group">
                    <label for="fontWeight">Yazı Kalınlığı:</label>
                    <select id="fontWeight">
                        <option value="normal">Normal</option>
                        <option value="bold" selected>Kalın</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="fontFamily">Yazı Tipi:</label>
                    <select id="fontFamily">
                      <option value="'system-ui', sans-serif">System UI</option>
                      <option value="'Segoe UI', sans-serif">Segoe UI</option>
                      <option value="Arial, sans-serif">Arial</option>
                      <option value="'Times New Roman', serif">Times New Roman</option>
                      <option value="Georgia, serif">Georgia</option>
                      <option value="monospace">Monospace</option>
                      <option value="cursive">Cursive</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="backgroundColor">Arka Plan Rengi:</label>
                    <input type="color" id="backgroundColor" value="#ffffff">
                </div>
            </div>
        </div>
        
        <div class="preview">
            <p id="previewText" class="preview-text">Gradyan örnek metin!</p>
            
            <!-- Gradient control overlay -->
            <div id="gradientControl" class="gradient-control" style="display: none;">
                <div id="gradientLine" class="gradient-line"></div>
                <div id="startCircle" class="gradient-circle start-circle"></div>
                <div id="endCircle" class="gradient-circle end-circle"></div>
            </div>
        </div>
        
        <div class="button-group">
            <button id="updatePreview">Önizlemeyi Güncelle</button>
            <button id="showCode">CSS Kodunu Göster</button>
            <button id="copyCode">CSS Kodunu Kopyala</button>
            <button id="downloadImage">Görseli İndir</button>
            <button id="copyImage">Görseli Kopyala</button>
        </div>
        
        <div id="codeOutput" class="code-output"></div>
    </div>

    <!-- For rendering text to canvas (download & copy image) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // DOM elementlerini seçme
        const userText = document.getElementById('userText');
        const firstColor = document.getElementById('firstColor');
        const secondColor = document.getElementById('secondColor');
        const gradientDirection = document.getElementById('gradientDirection');
        const fontSize = document.getElementById('fontSize');
        const lineHeight = document.getElementById('lineHeight');
        const textAlign = document.getElementById('textAlign');
        const fontWeight = document.getElementById('fontWeight');
        const fontFamily = document.getElementById('fontFamily');
        const backgroundColor = document.getElementById('backgroundColor');
        const previewText = document.getElementById('previewText');
        const previewContainer = document.querySelector('.preview');
        const updatePreviewBtn = document.getElementById('updatePreview');
        const showCodeBtn = document.getElementById('showCode');
        const copyCodeBtn = document.getElementById('copyCode');
        const downloadImageBtn = document.getElementById('downloadImage');
        const copyImageBtn = document.getElementById('copyImage');
        const codeOutput = document.getElementById('codeOutput');
        
        // Gradient control elements
        const gradientControl = document.getElementById('gradientControl');
        const gradientLine = document.getElementById('gradientLine');
        const startCircle = document.getElementById('startCircle');
        const endCircle = document.getElementById('endCircle');
        
        // Initial color for circles
        startCircle.style.backgroundColor = firstColor.value;
        endCircle.style.backgroundColor = secondColor.value;
        
        // Variables for custom gradient
        let angle = 0;
        let customGradientEnabled = false;
        
        // Sayfayı yüklerken önizlemeyi güncelle
        updatePreview();

        // Canlı güncelleme için input değişikliklerini dinle (opsiyonel)
        [
            userText, firstColor, secondColor, fontSize,
            lineHeight, textAlign, fontWeight, fontFamily, backgroundColor
        ].forEach(element => {
            element.addEventListener('input', updatePreview);
        });



        function updateCustomGradient() {
            // Get positions of circles
            const startRect = startCircle.getBoundingClientRect();
            const endRect = endCircle.getBoundingClientRect();
            const previewRect = previewContainer.getBoundingClientRect();
            const textRect = previewText.getBoundingClientRect();
            
            // Calculate center points of circles
            const startX = startRect.left + startRect.width / 2 - previewRect.left;
            const startY = startRect.top + startRect.height / 2 - previewRect.top;
            const endX = endRect.left + endRect.width / 2 - previewRect.left;
            const endY = endRect.top + endRect.height / 2 - previewRect.top;
            
            // Create linear gradient but with perpendicular direction to the line connecting the circles
            // This creates a gradient that changes based on proximity to each circle
            const dx = endX - startX;
            const dy = endY - startY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Calculate perpendicular angle (90 degrees rotated)
            const perpAngle = Math.atan2(dx, -dy) * (180 / Math.PI);
            
            // Create gradient with calculated angle
            const cssAngle = perpAngle;
            
            // Use multiple color stops for better proximity effect
            // Calculate the middle point between circles
            const midX = (startX + endX) / 2;
            const midY = (startY + endY) / 2;
            
            // Calculate distances from text edges to circles
            const textLeft = textRect.left - previewRect.left;
            const textRight = textRect.right - previewRect.left;
            const textTop = textRect.top - previewRect.top;
            const textBottom = textRect.bottom - previewRect.top;
            
            // Calculate distances from text corners to both circles
            const distTL_Start = Math.sqrt(Math.pow(textLeft - startX, 2) + Math.pow(textTop - startY, 2));
            const distTR_Start = Math.sqrt(Math.pow(textRight - startX, 2) + Math.pow(textTop - startY, 2));
            const distBL_Start = Math.sqrt(Math.pow(textLeft - startX, 2) + Math.pow(textBottom - startY, 2));
            const distBR_Start = Math.sqrt(Math.pow(textRight - startX, 2) + Math.pow(textBottom - startY, 2));
            
            const distTL_End = Math.sqrt(Math.pow(textLeft - endX, 2) + Math.pow(textTop - endY, 2));
            const distTR_End = Math.sqrt(Math.pow(textRight - endX, 2) + Math.pow(textTop - endY, 2));
            const distBL_End = Math.sqrt(Math.pow(textLeft - endX, 2) + Math.pow(textBottom - endY, 2));
            const distBR_End = Math.sqrt(Math.pow(textRight - endX, 2) + Math.pow(textBottom - endY, 2));
            
            // Determine which corner is closest to each circle
            const startClosestToTL = distTL_Start < distTL_End;
            const startClosestToTR = distTR_Start < distTR_End;
            const startClosestToBL = distBL_Start < distBL_End;
            const startClosestToBR = distBR_Start < distBR_End;
            
            // Calculate gradient angle based on which corners are closest to which circle
            let useAngle;
            
            // If diagonal dominance
            if ((startClosestToTL && startClosestToBR) || (startClosestToTR && startClosestToBL)) {
                // Use the original angle between circles
                useAngle = (90 - angle) % 360;
            } else if (startClosestToTL && startClosestToTR) {
                // Top edge is closer to start circle
                useAngle = 0; // top to bottom gradient
            } else if (startClosestToBL && startClosestToBR) {
                // Bottom edge is closer to start circle
                useAngle = 180; // bottom to top gradient
            } else if (startClosestToTL && startClosestToBL) {
                // Left edge is closer to start circle
                useAngle = 90; // left to right gradient
            } else if (startClosestToTR && startClosestToBR) {
                // Right edge is closer to start circle
                useAngle = 270; // right to left gradient
            } else {
                // Default to the angle between circles
                useAngle = (90 - angle) % 360;
            }
            
            // Apply gradient
            previewText.style.background = `linear-gradient(${useAngle}deg, ${firstColor.value}, ${secondColor.value})`;
            previewText.style.webkitBackgroundClip = 'text';
            previewText.style.backgroundClip = 'text';
            previewText.style.color = 'transparent';
        }

        // Update circle colors when input changes
        firstColor.addEventListener('input', function() {
            startCircle.style.backgroundColor = firstColor.value;
            if (customGradientEnabled) {
                updateCustomGradient();
            }
        });
        
        secondColor.addEventListener('input', function() {
            endCircle.style.backgroundColor = secondColor.value;
            if (customGradientEnabled) {
                updateCustomGradient();
            }
        });
        
        // Toggle custom gradient control based on dropdown selection
        gradientDirection.addEventListener('change', function() {
            customGradientEnabled = this.value === 'custom';
            gradientControl.style.display = customGradientEnabled ? 'block' : 'none';
            
            if (customGradientEnabled) {
                // Initialize positions
                initializeGradientControl();
                updateCustomGradient();
            } else {
                updatePreview();
            }
        });
        
        // Initialize gradient control positions and size
        function initializeGradientControl() {
            // Default positions (can be adjusted)
            const previewRect = previewContainer.getBoundingClientRect();
            
            // Update line dimensions based on preview container
            updateGradientLine();
        }
        
        // Make circles draggable
        makeDraggable(startCircle);
        makeDraggable(endCircle);
        
        function makeDraggable(element) {
            let isDragging = false;
            let startX, startY;
            let initialLeft, initialTop;
            
            element.addEventListener('mousedown', function(e) {
                isDragging = true;
                e.preventDefault();
                
                // Get initial mouse position
                startX = e.clientX;
                startY = e.clientY;
                
                // Get current position of the element
                const rect = element.getBoundingClientRect();
                initialLeft = rect.left - previewContainer.getBoundingClientRect().left;
                initialTop = rect.top - previewContainer.getBoundingClientRect().top;
                
                // Add event listeners for dragging
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
            
            function onMouseMove(e) {
                if (!isDragging) return;
                
                // Calculate new position
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                const newLeft = initialLeft + deltaX;
                const newTop = initialTop + deltaY;
                
                // Constrain to preview container
                const previewRect = previewContainer.getBoundingClientRect();
                const elementRadius = element.offsetWidth / 2;
                
                const maxLeft = previewRect.width - elementRadius;
                const maxTop = previewRect.height - elementRadius;
                
                const constrainedLeft = Math.max(elementRadius, Math.min(newLeft, maxLeft));
                const constrainedTop = Math.max(elementRadius, Math.min(newTop, maxTop));
                
                // Update element position
                element.style.left = constrainedLeft + 'px';
                element.style.top = constrainedTop + 'px';
                
                // Update the gradient
                updateGradientLine();
                updateCustomGradient();
            }
            
            function onMouseUp() {
                isDragging = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
        }
        
        // Update the gradient line connecting the circles
        function updateGradientLine() {
            const startRect = startCircle.getBoundingClientRect();
            const endRect = endCircle.getBoundingClientRect();
            const previewRect = previewContainer.getBoundingClientRect();
            
            // Calculate center points
            const startX = startRect.left + startRect.width / 2 - previewRect.left;
            const startY = startRect.top + startRect.height / 2 - previewRect.top;
            const endX = endRect.left + endRect.width / 2 - previewRect.left;
            const endY = endRect.top + endRect.height / 2 - previewRect.top;
            
            // Calculate angle and length
            const deltaX = endX - startX;
            const deltaY = endY - startY;
            const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
            
            // Position line at start circle center
            gradientLine.style.left = startX + 'px';
            gradientLine.style.top = startY + 'px';
            gradientLine.style.width = length + 'px';
            gradientLine.style.transform = `rotate(${angle}deg)`;
            gradientLine.style.transformOrigin = '0 50%';
        }
        
        // Update the gradient based on circle positions
/*         function updateCustomGradient() {
            // Calculate gradient angle (CSS uses a different angle system)
            const cssAngle = (90 - angle) % 360;
            previewText.style.background = `linear-gradient(${cssAngle}deg, ${firstColor.value}, ${secondColor.value})`;
            previewText.style.webkitBackgroundClip = 'text';
            previewText.style.backgroundClip = 'text';
            previewText.style.color = 'transparent';
        } */

        // Önizlemeyi güncelle butonu
        updatePreviewBtn.addEventListener('click', updatePreview);

        // Preview update function
        function updatePreview() {
            previewText.textContent = userText.value || 'Metin girin';
            
            if (customGradientEnabled) {
                updateCustomGradient();
            } else {
                previewText.style.background = `linear-gradient(${gradientDirection.value}, ${firstColor.value}, ${secondColor.value})`;
                previewText.style.webkitBackgroundClip = 'text';
                previewText.style.backgroundClip = 'text';
                previewText.style.color = 'transparent';
            }
            
            previewText.style.fontSize = `${fontSize.value}px`;
            previewText.style.lineHeight = lineHeight.value;
            previewText.style.textAlign = textAlign.value;
            previewText.style.fontWeight = fontWeight.value;
            previewText.style.fontFamily = fontFamily.value;
            previewContainer.style.backgroundColor = backgroundColor.value;

            if (codeOutput.style.display === 'block') {
                generateCode();
            }
        }

        // CSS kodunu göster butonu
        showCodeBtn.addEventListener('click', function() {
            generateCode();
            codeOutput.style.display = 
                codeOutput.style.display === 'none' || codeOutput.style.display === '' 
                ? 'block' 
                : 'none';
            showCodeBtn.textContent = 
                codeOutput.style.display === 'none' 
                ? 'CSS Kodunu Göster' 
                : 'CSS Kodunu Gizle';
        });

        // CSS kodunu kopyala butonu
        copyCodeBtn.addEventListener('click', function() {
            generateCode();
            navigator.clipboard.writeText(codeOutput.textContent)
                .then(() => {
                    const originalText = copyCodeBtn.textContent;
                    copyCodeBtn.textContent = 'Kopyalandı!';
                    setTimeout(() => {
                        copyCodeBtn.textContent = originalText;
                    }, 1500);
                })
                .catch(err => {
                    console.error('Kopyalama başarısız: ', err);
                });
        });

        // CSS kodunu oluşturma fonksiyonu
        function generateCode() {
            let gradientCSS;
            
            if (customGradientEnabled) {
                const cssAngle = 90 + angle;
                gradientCSS = `linear-gradient(${cssAngle}deg, ${firstColor.value}, ${secondColor.value})`;
            } else {
                gradientCSS = `linear-gradient(${gradientDirection.value}, ${firstColor.value}, ${secondColor.value})`;
            }
            
            const css = `.gradyan-metin {
    background: ${gradientCSS};
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    font-size: ${fontSize.value}px;
    line-height: ${lineHeight.value};
    text-align: ${textAlign.value};
    font-weight: ${fontWeight.value};
    font-family: ${fontFamily.value};
}

.gradyan-metin-container {
    background-color: ${backgroundColor.value};
    padding: 20px;
}`;
            codeOutput.textContent = css;
        }

        // Görseli indir
        downloadImageBtn.addEventListener('click', function() {
            const canvas = drawGradientTextToCanvas();
            const link = document.createElement('a');
            link.download = 'gradyan-metin.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        });

        // Görseli kopyala
        copyImageBtn.addEventListener('click', function() {
            const canvas = drawGradientTextToCanvas();
            canvas.toBlob(blob => {
                navigator.clipboard.write([
                    new ClipboardItem({ 'image/png': blob })
                ]).then(() => {
                    const originalText = copyImageBtn.textContent;
                    copyImageBtn.textContent = 'Kopyalandı!';
                    setTimeout(() => {
                        copyImageBtn.textContent = originalText;
                    }, 1500);
                }).catch(err => {
                    console.error('Görsel kopyalama başarısız: ', err);
                    alert('Görsel kopyalama başarısız. HTTPS sunucusu kullanmayı deneyin.');
                });
            });
        });

        // Canvas'a gradyanlı metni çizme fonksiyonu (indir/kopyala için)
        function drawGradientTextToCanvas() {
            html2canvas(previewContainer, {
                backgroundColor: backgroundColor.value,
                scale: 2, // Yüksek DPI için ölçeği artır
                logging: false,
                onclone: function(clonedDoc) {
                    const clonedPreview = clonedDoc.querySelector('.preview');
                    clonedPreview.style.boxShadow = 'none';
                    clonedPreview.style.border = 'none';
                    
                    // Hide gradient control elements in the clone
                    const clonedControl = clonedDoc.querySelector('.gradient-control');
                    if (clonedControl) {
                        clonedControl.style.display = 'none';
                    }
                }
            }).then(canvas => {
                return canvas;
            }).catch(error => {
                console.error('Render hatası:', error);
                return document.createElement('canvas');
            });
            
            // Fallback to simple canvas if html2canvas fails
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const scale = 3; // Çözünürlük ölçeği
            
            // Metni ölç
            ctx.font = `${fontWeight.value} ${fontSize.value}px ${fontFamily.value}`;
            const text = userText.value || 'Metin girin';
            const textMetrics = ctx.measureText(text);
            
            // Canvas boyutlarını metne göre dinamik ayarla
            canvas.width = Math.max(textMetrics.width * 1.5, 600) * scale;
            canvas.height = (parseInt(fontSize.value) * 2) * scale;
            ctx.scale(scale, scale);

            // Arka planı çiz
            ctx.fillStyle = backgroundColor.value;
            ctx.fillRect(0, 0, canvas.width / scale, canvas.height / scale);
            
            // Create gradient
            // Create gradient
            let gradient;
            if (customGradientEnabled) {
                // Convert angle to CSS angle then to radians for canvas
                const cssAngle = (90 - angle) % 360;
                const angleRad = cssAngle * Math.PI / 180;
                const centerX = canvas.width / (2 * scale);
                const centerY = canvas.height / (2 * scale);
                const radius = Math.max(canvas.width, canvas.height) / (2 * scale);
                
                // Calculate gradient endpoints
                const startX = centerX - Math.cos(angleRad) * radius;
                const startY = centerY - Math.sin(angleRad) * radius;
                const endX = centerX + Math.cos(angleRad) * radius;
                const endY = centerY + Math.sin(angleRad) * radius;
                
                gradient = ctx.createLinearGradient(startX, startY, endX, endY);
            } else {
                // Default gradient based on direction
                switch (gradientDirection.value) {
                    case 'to right':
                        gradient = ctx.createLinearGradient(0, 0, canvas.width / scale, 0);
                        break;
                    case 'to left':
                        gradient = ctx.createLinearGradient(canvas.width / scale, 0, 0, 0);
                        break;
                    case 'to bottom':
                        gradient = ctx.createLinearGradient(0, 0, 0, canvas.height / scale);
                        break;
                    case 'to top':
                        gradient = ctx.createLinearGradient(0, canvas.height / scale, 0, 0);
                        break;
                    case 'to bottom right':
                        gradient = ctx.createLinearGradient(0, 0, canvas.width / scale, canvas.height / scale);
                        break;
                    case 'to bottom left':
                        gradient = ctx.createLinearGradient(canvas.width / scale, 0, 0, canvas.height / scale);
                        break;
                    default:
                        gradient = ctx.createLinearGradient(0, 0, canvas.width / scale, 0);
                }
            }
            
            gradient.addColorStop(0, firstColor.value);
            gradient.addColorStop(1, secondColor.value);

            // Metni ortalayarak çiz
            ctx.font = `${fontWeight.value} ${fontSize.value}px ${fontFamily.value}`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = gradient;
            ctx.fillText(text, canvas.width / (2 * scale), canvas.height / (2 * scale));

            return canvas;
        }
        
        // Initialize positions on load if custom is selected
        if (gradientDirection.value === 'custom') {
            customGradientEnabled = true;
            gradientControl.style.display = 'block';
            initializeGradientControl();
            updateCustomGradient();
        }
    });
    </script>
</body>
</html>